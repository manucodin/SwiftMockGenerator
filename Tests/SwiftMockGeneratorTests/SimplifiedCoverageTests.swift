import XCTest
@testable import SwiftMockGeneratorLib
import Foundation

final class SimplifiedCoverageTests: XCTestCase {
    
    // MARK: - System Under Test - Basic Generator Coverage
    
    func testStubGenerator_whenGeneratingMockFromProtocol_thenProducesValidCode() throws {
        // Given
        let sut = StubGenerator()
        let protocolElement = ProtocolElement(name: "TestProtocol")
        let annotation = MockAnnotation(
            type: .stub,
            element: .protocol(protocolElement),
            location: SourceLocation(line: 1, column: 1, file: "test.swift")
        )
        
        // When
        let result = try sut.generateMock(for: annotation.element, annotation: annotation)
        
        // Then
        XCTAssertFalse(result.isEmpty)
        XCTAssertTrue(result.contains("TestProtocol"))
        XCTAssertTrue(result.contains("Generated by SwiftMockGenerator"))
    }
    
    func testSpyGenerator_whenGeneratingMockFromProtocol_thenProducesSpyCode() throws {
        // Given
        let sut = SpyGenerator()
        let protocolElement = ProtocolElement(name: "TestProtocol")
        let annotation = MockAnnotation(
            type: .spy,
            element: .protocol(protocolElement),
            location: SourceLocation(line: 1, column: 1, file: "test.swift")
        )
        
        // When
        let result = try sut.generateMock(for: annotation.element, annotation: annotation)
        
        // Then
        XCTAssertFalse(result.isEmpty)
        XCTAssertTrue(result.contains("TestProtocol"))
        XCTAssertTrue(result.contains("Spy"))
        XCTAssertTrue(result.contains("// MARK: - Reset"))
    }
    
    func testDummyGenerator_whenGeneratingMockFromProtocol_thenProducesDummyCode() throws {
        // Given
        let sut = DummyGenerator()
        let protocolElement = ProtocolElement(name: "TestProtocol")
        let annotation = MockAnnotation(
            type: .dummy,
            element: .protocol(protocolElement),
            location: SourceLocation(line: 1, column: 1, file: "test.swift")
        )
        
        // When
        let result = try sut.generateMock(for: annotation.element, annotation: annotation)
        
        // Then
        XCTAssertFalse(result.isEmpty)
        XCTAssertTrue(result.contains("TestProtocol"))
        XCTAssertTrue(result.contains("Dummy"))
        XCTAssertTrue(result.contains("does nothing"))
    }
    
    func testAllGenerators_whenGeneratingMocksForDifferentElements_thenAllSucceed() throws {
        // Given
        let generators: [(MockGeneratorProtocol, MockType)] = [
            (StubGenerator(), .stub),
            (SpyGenerator(), .spy),
            (DummyGenerator(), .dummy)
        ]
        
        let elements: [CodeElement] = [
            .protocol(ProtocolElement(name: "TestProtocol")),
            .class(ClassElement(name: "TestClass")),
            .function(FunctionElement(name: "testFunction"))
        ]
        
        // When & Then
        for (sut, mockType) in generators {
            for element in elements {
                let annotation = MockAnnotation(
                    type: mockType,
                    element: element,
                    location: SourceLocation(line: 1, column: 1, file: "test.swift")
                )
                
                let result = try sut.generateMock(for: element, annotation: annotation)
                
                XCTAssertFalse(result.isEmpty, "Generator \(mockType) failed for element \(element.name)")
                XCTAssertTrue(result.contains(element.name), "Generated code doesn't contain element name")
                XCTAssertTrue(result.contains(mockType.rawValue), "Generated code doesn't contain mock type")
            }
        }
    }
    
    // MARK: - SyntaxParser SUT Tests
    
    func testSyntaxParser_whenParsingRealSwiftCode_thenDoesNotCrash() {
        // Given
        let sut = SyntaxParser()
        let swiftCode = """
        import Foundation
        
        protocol NetworkService {
            func fetchData() -> String
        }
        
        class UserManager {
            func getUser() -> String { return "" }
        }
        """
        
        // When
        let result = sut.parseAnnotations(from: swiftCode, filePath: "test.swift")
        
        // Then
        XCTAssertGreaterThanOrEqual(result.count, 0)
    }
    
    func testSyntaxParser_whenParsingEmptyCode_thenReturnsEmptyAnnotations() {
        // Given
        let sut = SyntaxParser()
        let emptyCode = ""
        
        // When
        let result = sut.parseAnnotations(from: emptyCode, filePath: "test.swift")
        
        // Then
        XCTAssertEqual(result.count, 0)
    }
    
    func testAnnotationVisitor_whenInitialized_thenHasEmptyAnnotations() {
        // Given
        let filePath = "test.swift"
        let sourceText = "test content"
        
        // When
        let sut = AnnotationVisitor(filePath: filePath, sourceText: sourceText)
        
        // Then
        XCTAssertNotNil(sut)
        XCTAssertEqual(sut.annotations.count, 0)
    }
    
    // MARK: - MockGenerator SUT Tests
    
    func testMockGenerator_whenGeneratingMocksInEmptyDirectory_thenCreatesOutputDirectory() async throws {
        // Given
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("MockGeneratorTest")
            .appendingPathComponent(UUID().uuidString)
        let outputDir = tempDir.appendingPathComponent("Mocks")
        
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }
        
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let sut = MockGenerator(
            inputPath: tempDir.path,
            outputPath: outputDir.path
        )
        
        // When
        try await sut.generateMocks()
        
        // Then
        XCTAssertTrue(FileManager.default.fileExists(atPath: outputDir.path))
    }
    
    func testMockGenerator_whenCleaningExistingOutputDirectory_thenRemovesDirectory() throws {
        // Given
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("MockGeneratorCleanTest")
            .appendingPathComponent(UUID().uuidString)
        
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }
        
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        try "test".write(to: tempDir.appendingPathComponent("test.txt"), atomically: true, encoding: .utf8)
        
        let sut = MockGenerator(
            inputPath: "/nonexistent",
            outputPath: tempDir.path
        )
        
        // When
        try sut.cleanOutputDirectory()
        
        // Then
        XCTAssertFalse(FileManager.default.fileExists(atPath: tempDir.path))
    }
    
    func testMockGenerator_whenProcessingEmptyDirectory_thenHandlesGracefully() async throws {
        // Given
        let tempDir = FileManager.default.temporaryDirectory
            .appendingPathComponent("EmptyTest")
            .appendingPathComponent(UUID().uuidString)
        
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }
        
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        let sut = MockGenerator(
            inputPath: tempDir.path,
            outputPath: tempDir.appendingPathComponent("output").path
        )
        
        // When & Then (should not throw)
        try await sut.generateMocks()
        XCTAssertTrue(true) // If we get here without crashing, test passes
    }
    
    func testMockGenerator_whenGivenInvalidPath_thenHandlesErrorGracefully() async {
        // Given
        let sut = MockGenerator(
            inputPath: "/completely/nonexistent/path",
            outputPath: "/also/nonexistent"
        )
        
        // When & Then
        do {
            try await sut.generateMocks()
            // If no error thrown, we still consider this a pass for basic functionality
            XCTAssertTrue(true)
        } catch {
            // Expected to handle error gracefully
            XCTAssertTrue(error is MockGeneratorError || error is CocoaError)
        }
    }
    
    // MARK: - Access Level SUT Tests
    
    func testAccessLevel_whenGettingKeyword_thenReturnsCorrectFormat() {
        // Given
        let testCases: [(AccessLevel, String)] = [
            (.private, "private "),
            (.fileprivate, "fileprivate "),
            (.internal, ""),
            (.public, "public "),
            (.open, "open ")
        ]
        
        // When & Then
        for (sut, expectedKeyword) in testCases {
            XCTAssertEqual(sut.keyword, expectedKeyword)
        }
    }
    
    // MARK: - MockType SUT Tests
    
    func testMockType_whenAccessingAllCases_thenContainsAllTypes() {
        // Given
        let expectedCount = 3
        let expectedTypes: [MockType] = [.stub, .spy, .dummy]
        
        // When
        let sut = MockType.allCases
        
        // Then
        XCTAssertEqual(sut.count, expectedCount)
        for expectedType in expectedTypes {
            XCTAssertTrue(sut.contains(expectedType))
        }
    }
    
    
    // MARK: - CodeElement Reference Semantics SUT Tests
    
    func testCodeElement_whenCheckingReferenceSemantics_thenReturnsCorrectValues() {
        // Given
        let protocolElement = CodeElement.protocol(ProtocolElement(name: "TestProtocol"))
        let classElement = CodeElement.class(ClassElement(name: "TestClass"))
        let functionElement = CodeElement.function(FunctionElement(name: "testFunction"))
        
        // When & Then
        XCTAssertTrue(protocolElement.isReference)
        XCTAssertTrue(classElement.isReference)
        XCTAssertFalse(functionElement.isReference)
    }
    
    // MARK: - Element Properties SUT Tests
    
    func testProtocolElement_whenCreatedWithCompleteData_thenStoresAllProperties() {
        // Given
        let name = "ComplexProtocol"
        let methods = [MethodElement(name: "testMethod")]
        let properties = [PropertyElement(name: "testProperty", type: "String")]
        let inheritance = ["ParentProtocol"]
        let accessLevel = AccessLevel.public
        let genericParameters = ["T"]
        
        // When
        let sut = ProtocolElement(
            name: name,
            methods: methods,
            properties: properties,
            inheritance: inheritance,
            accessLevel: accessLevel,
            genericParameters: genericParameters
        )
        
        // Then
        XCTAssertEqual(sut.name, name)
        XCTAssertEqual(sut.methods.count, 1)
        XCTAssertEqual(sut.properties.count, 1)
        XCTAssertEqual(sut.inheritance.count, 1)
        XCTAssertEqual(sut.accessLevel, accessLevel)
        XCTAssertEqual(sut.genericParameters.count, 1)
    }
    
    func testClassElement_whenCreatedWithCompleteData_thenStoresAllProperties() {
        // Given
        let name = "ComplexClass"
        let methods = [MethodElement(name: "testMethod")]
        let properties = [PropertyElement(name: "testProperty", type: "String")]
        let initializers = [InitializerElement()]
        let inheritance = ["ParentClass"]
        let accessLevel = AccessLevel.internal
        let genericParameters = ["T"]
        let isFinal = true
        
        // When
        let sut = ClassElement(
            name: name,
            methods: methods,
            properties: properties,
            initializers: initializers,
            inheritance: inheritance,
            accessLevel: accessLevel,
            genericParameters: genericParameters,
            isFinal: isFinal
        )
        
        // Then
        XCTAssertEqual(sut.name, name)
        XCTAssertEqual(sut.methods.count, 1)
        XCTAssertEqual(sut.properties.count, 1)
        XCTAssertEqual(sut.initializers.count, 1)
        XCTAssertEqual(sut.inheritance.count, 1)
        XCTAssertEqual(sut.accessLevel, accessLevel)
        XCTAssertEqual(sut.genericParameters.count, 1)
        XCTAssertTrue(sut.isFinal)
    }
    
    
    func testFunctionElement_whenCreatedWithCompleteData_thenStoresAllProperties() {
        // Given
        let name = "complexFunction"
        let parameter = ParameterElement(internalName: "value", type: "String")
        let parameters = [parameter]
        let returnType = "Bool"
        let accessLevel = AccessLevel.public
        let isStatic = true
        let isAsync = true
        let isThrowing = true
        let genericParameters = ["T"]
        
        // When
        let sut = FunctionElement(
            name: name,
            parameters: parameters,
            returnType: returnType,
            accessLevel: accessLevel,
            isStatic: isStatic,
            isAsync: isAsync,
            isThrowing: isThrowing,
            genericParameters: genericParameters
        )
        
        // Then
        XCTAssertEqual(sut.name, name)
        XCTAssertEqual(sut.parameters.count, 1)
        XCTAssertEqual(sut.returnType, returnType)
        XCTAssertEqual(sut.accessLevel, accessLevel)
        XCTAssertTrue(sut.isStatic)
        XCTAssertTrue(sut.isAsync)
        XCTAssertTrue(sut.isThrowing)
        XCTAssertEqual(sut.genericParameters.count, 1)
    }
    
    // MARK: - Supporting Elements SUT Tests
    
    func testMethodElement_whenCreatedWithAllModifiers_thenStoresAllProperties() {
        // Given
        let name = "complexMethod"
        let parameter = ParameterElement(internalName: "input", type: "String")
        let parameters = [parameter]
        let returnType = "String"
        let accessLevel = AccessLevel.public
        let isStatic = true
        let isAsync = true
        let isThrowing = true
        let isMutating = true
        let genericParameters = ["T"]
        
        // When
        let sut = MethodElement(
            name: name,
            parameters: parameters,
            returnType: returnType,
            accessLevel: accessLevel,
            isStatic: isStatic,
            isAsync: isAsync,
            isThrowing: isThrowing,
            isMutating: isMutating,
            genericParameters: genericParameters
        )
        
        // Then
        XCTAssertEqual(sut.name, name)
        XCTAssertEqual(sut.parameters.count, 1)
        XCTAssertEqual(sut.returnType, returnType)
        XCTAssertEqual(sut.accessLevel, accessLevel)
        XCTAssertTrue(sut.isStatic)
        XCTAssertTrue(sut.isAsync)
        XCTAssertTrue(sut.isThrowing)
        XCTAssertTrue(sut.isMutating)
        XCTAssertEqual(sut.genericParameters.count, 1)
    }
    
    func testPropertyElement_whenCreatedWithAllModifiers_thenStoresAllProperties() {
        // Given
        let name = "complexProperty"
        let type = "String"
        let accessLevel = AccessLevel.public
        let isStatic = true
        let hasGetter = true
        let hasSetter = true
        let isLazy = true
        
        // When
        let sut = PropertyElement(
            name: name,
            type: type,
            accessLevel: accessLevel,
            isStatic: isStatic,
            hasGetter: hasGetter,
            hasSetter: hasSetter,
            isLazy: isLazy
        )
        
        // Then
        XCTAssertEqual(sut.name, name)
        XCTAssertEqual(sut.type, type)
        XCTAssertEqual(sut.accessLevel, accessLevel)
        XCTAssertTrue(sut.isStatic)
        XCTAssertTrue(sut.hasGetter)
        XCTAssertTrue(sut.hasSetter)
        XCTAssertTrue(sut.isLazy)
    }
    
    func testParameterElement_whenCreatedWithAllModifiers_thenStoresAllProperties() {
        // Given
        let externalName = "from"
        let internalName = "source"
        let type = "String"
        let defaultValue = "\"default\""
        let isInout = true
        let isVariadic = true
        
        // When
        let sut = ParameterElement(
            externalName: externalName,
            internalName: internalName,
            type: type,
            defaultValue: defaultValue,
            isInout: isInout,
            isVariadic: isVariadic
        )
        
        // Then
        XCTAssertEqual(sut.externalName, externalName)
        XCTAssertEqual(sut.internalName, internalName)
        XCTAssertEqual(sut.type, type)
        XCTAssertEqual(sut.defaultValue, defaultValue)
        XCTAssertTrue(sut.isInout)
        XCTAssertTrue(sut.isVariadic)
    }
    
    func testInitializerElement_whenCreatedWithAllModifiers_thenStoresAllProperties() {
        // Given
        let parameter = ParameterElement(internalName: "value", type: "String")
        let parameters = [parameter]
        let accessLevel = AccessLevel.public
        let isFailable = true
        let isConvenience = true
        let isThrowing = true
        
        // When
        let sut = InitializerElement(
            parameters: parameters,
            accessLevel: accessLevel,
            isFailable: isFailable,
            isConvenience: isConvenience,
            isThrowing: isThrowing
        )
        
        // Then
        XCTAssertEqual(sut.parameters.count, 1)
        XCTAssertEqual(sut.accessLevel, accessLevel)
        XCTAssertTrue(sut.isFailable)
        XCTAssertTrue(sut.isConvenience)
        XCTAssertTrue(sut.isThrowing)
    }
    
    
    // MARK: - Error Types SUT Tests
    
    func testMockGeneratorError_whenCreated_thenHasCorrectDescription() {
        // Given
        let path = "/test/path"
        let fileName = "file.swift"
        let message = "generation failed"
        let underlyingError = NSError(domain: "test", code: 1)
        
        // When
        let invalidPathSUT = MockGeneratorError.invalidInputPath(path)
        let processingErrorSUT = MockGeneratorError.fileProcessingError(fileName, underlyingError)
        let generationErrorSUT = MockGeneratorError.mockGenerationError(message)
        
        // Then
        XCTAssertNotNil(invalidPathSUT.errorDescription)
        XCTAssertNotNil(processingErrorSUT.errorDescription)
        XCTAssertNotNil(generationErrorSUT.errorDescription)
        
        XCTAssertTrue(invalidPathSUT.errorDescription!.contains(path))
        XCTAssertTrue(processingErrorSUT.errorDescription!.contains(fileName))
        XCTAssertTrue(generationErrorSUT.errorDescription!.contains(message))
    }
    
    // MARK: - Source Location SUT Tests
    
    func testSourceLocation_whenCreated_thenStoresAllProperties() {
        // Given
        let line = 42
        let column = 15
        let file = "TestFile.swift"
        
        // When
        let sut = SourceLocation(line: line, column: column, file: file)
        
        // Then
        XCTAssertEqual(sut.line, line)
        XCTAssertEqual(sut.column, column)
        XCTAssertEqual(sut.file, file)
    }
    
    // MARK: - MockAnnotation SUT Tests
    
    func testMockAnnotation_whenCreatedWithCompleteData_thenStoresAllProperties() {
        // Given
        let element = ProtocolElement(name: "TestProtocol")
        let location = SourceLocation(line: 1, column: 1, file: "test.swift")
        let mockType = MockType.stub
        
        // When
        let sut = MockAnnotation(
            type: mockType,
            element: .protocol(element),
            location: location,
        )
        
        // Then
        XCTAssertEqual(sut.type, mockType)
        XCTAssertEqual(sut.element.name, "TestProtocol")
        XCTAssertEqual(sut.location.file, "test.swift")
    }
    
    // MARK: - Generator Output Structure SUT Tests
    
    func testGenerators_whenGeneratingCode_thenProduceRequiredStructure() throws {
        // Given
        let generators: [MockGeneratorProtocol] = [
            StubGenerator(),
            SpyGenerator(),
            DummyGenerator()
        ]
        let element = ProtocolElement(name: "TestProtocol")
        
        // When & Then
        for sut in generators {
            let annotation = MockAnnotation(
                type: .stub,
                element: .protocol(element),
                location: SourceLocation(line: 1, column: 1, file: "test.swift")
            )
            
            let result = try sut.generateMock(for: annotation.element, annotation: annotation)
            
            // All generators should produce basic structure
            XCTAssertTrue(result.contains("MARK:"), "Generator output should contain MARK comments")
            XCTAssertTrue(result.contains("TestProtocol"), "Generator output should contain element name")
            XCTAssertTrue(result.contains("Generated by SwiftMockGenerator"), "Generator output should contain attribution")
            XCTAssertTrue(result.contains("class") || result.contains("struct"), "Generator output should contain type declaration")
        }
    }
    
    func testGenerators_whenGivenDifferentElementTypes_thenGenerateAppropriateCode() throws {
        // Given
        let testCases: [(CodeElement, String)] = [
            (.protocol(ProtocolElement(name: "TestProtocol")), "TestProtocol"),
            (.class(ClassElement(name: "TestClass")), "TestClass"),
            (.function(FunctionElement(name: "testFunction")), "testFunction")
        ]
        let sut = StubGenerator()
        
        // When & Then
        for (element, expectedName) in testCases {
            let annotation = MockAnnotation(
                type: .stub,
                element: element,
                location: SourceLocation(line: 1, column: 1, file: "test.swift")
            )
            
            let result = try sut.generateMock(for: element, annotation: annotation)
            
            XCTAssertFalse(result.isEmpty, "Code should be generated for element \(expectedName)")
            XCTAssertTrue(result.contains(expectedName), "Code should contain element name")
        }
    }
    
    // MARK: - Edge Cases SUT Tests
    
    func testGenerators_whenGivenEmptyElementNames_thenDoNotCrash() throws {
        // Given
        let generators: [MockGeneratorProtocol] = [StubGenerator(), SpyGenerator(), DummyGenerator()]
        let emptyElements: [CodeElement] = [
            .protocol(ProtocolElement(name: "")),
            .class(ClassElement(name: "")),
            .function(FunctionElement(name: ""))
        ]
        
        // When & Then
        for sut in generators {
            for element in emptyElements {
                let annotation = MockAnnotation(
                    type: .stub,
                    element: element,
                    location: SourceLocation(line: 1, column: 1, file: "test.swift")
                )
                
                // Should not crash with empty names
                let result = try sut.generateMock(for: element, annotation: annotation)
                XCTAssertFalse(result.isEmpty)
            }
        }
    }
}