import Foundation

// MARK: - Dummy Generator

/// Generates dummy implementations that do nothing but satisfy compile-time requirements
public class DummyGenerator: MockGeneratorProtocol {
    public init() {}
    
    public func generateMock(for element: CodeElement, annotation: MockAnnotation, useResult: Bool = false) throws -> String {
        switch element {
        case .protocol(let protocolElement):
            return generateProtocolDummy(protocolElement, annotation: annotation, useResult: useResult)
        case .class(let classElement):
            return generateClassDummy(classElement, annotation: annotation, useResult: useResult)
        case .function(let functionElement):
            return generateFunctionDummy(functionElement, annotation: annotation, useResult: useResult)
        }
    }
    
    public func generateMockDefinition(for element: CodeElement, annotation: MockAnnotation, useResult: Bool = false) throws -> String {
        // Get the full mock code and remove the header (first 2 lines)
        let fullMock = try generateMock(for: element, annotation: annotation, useResult: useResult)
        let lines = fullMock.components(separatedBy: .newlines)
        return lines.dropFirst(2).joined(separator: "\n")
    }
    
    // MARK: - Protocol Dummy Generation
    
    private func generateProtocolDummy(_ protocolElement: ProtocolElement, annotation: MockAnnotation, useResult: Bool = false) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Dummy for \(protocolElement.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("// This is a dummy implementation that does nothing")
        output.append("")
        
        // Class declaration
        let className = "\(protocolElement.name)Dummy"
        let genericClause = protocolElement.genericParameters.isEmpty ? "" : "<\(protocolElement.genericParameters.joined(separator: ", "))>"
        let inheritanceClause = protocolElement.inheritance.isEmpty ? protocolElement.name : "\(protocolElement.name), \(protocolElement.inheritance.joined(separator: ", "))"
        let sendableAttribute = protocolElement.isSendable ? "@unchecked Sendable " : ""
        
        output.append("\(protocolElement.accessLevel.keyword)\(sendableAttribute)class \(className)\(genericClause): \(inheritanceClause) {")
        output.append("")
        
        // Properties - minimal implementation
        for property in protocolElement.properties {
            output.append("    \(generateDummyProperty(property))")
        }
        
        if !protocolElement.properties.isEmpty && !protocolElement.methods.isEmpty {
            output.append("")
        }
        
        // Initializer
        output.append("    \(protocolElement.accessLevel.keyword)init() {}")
        
        // Generate return value properties for async methods when using useResult
        if useResult {
            let hasAsyncMethods = protocolElement.methods.contains { $0.isAsync && $0.returnType != nil && $0.returnType != "Void" }
            if hasAsyncMethods {
                output.append("")
                for method in protocolElement.methods {
                    if let returnValueProperty = generateReturnValueProperty(method, useResult: useResult) {
                        output.append("    \(returnValueProperty)")
                    }
                }
            }
        }
        
        if !protocolElement.methods.isEmpty {
            output.append("")
        }
        
        // Methods - empty implementations
        for method in protocolElement.methods {
            output.append("    \(generateDummyMethod(method, useResult: useResult))")
            output.append("")
        }
        
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    // MARK: - Class Dummy Generation
    
    private func generateClassDummy(_ classElement: ClassElement, annotation: MockAnnotation, useResult: Bool = false) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Dummy for \(classElement.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("// This is a dummy implementation that does nothing")
        output.append("")
        
        // Class declaration
        let className = "\(classElement.name)Dummy"
        let genericClause = classElement.genericParameters.isEmpty ? "" : "<\(classElement.genericParameters.joined(separator: ", "))>"
        let inheritanceClause = classElement.inheritance.isEmpty ? classElement.name : "\(classElement.name), \(classElement.inheritance.joined(separator: ", "))"
        let sendableAttribute = classElement.isSendable ? "@unchecked Sendable " : ""
        
        output.append("\(classElement.accessLevel.keyword)\(sendableAttribute)class \(className)\(genericClause): \(inheritanceClause) {")
        output.append("")
        
        // Override properties if needed - minimal implementation
        for property in classElement.properties {
            output.append("    \(generateDummyPropertyOverride(property))")
        }
        
        if !classElement.properties.isEmpty && (!classElement.initializers.isEmpty || !classElement.methods.isEmpty) {
            output.append("")
        }
        
        // Initializers
        if !classElement.initializers.isEmpty {
            for initializer in classElement.initializers {
                output.append("    \(generateDummyInitializer(initializer))")
                output.append("")
            }
        } else {
            output.append("    \(classElement.accessLevel.keyword)override init() {")
            output.append("        super.init()")
            output.append("    }")
            output.append("")
        }
        
        // Generate return value properties for async methods when using useResult
        if useResult {
            let hasAsyncMethods = classElement.methods.contains { $0.isAsync && $0.returnType != nil && $0.returnType != "Void" }
            if hasAsyncMethods {
                output.append("")
                for method in classElement.methods {
                    if let returnValueProperty = generateReturnValueProperty(method, useResult: useResult) {
                        output.append("    \(returnValueProperty)")
                    }
                }
            }
        }
        
        // Override methods - empty implementations
        for method in classElement.methods {
            output.append("    \(generateDummyMethodOverride(method, useResult: useResult))")
            output.append("")
        }
        
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    
    // MARK: - Function Dummy Generation
    
    private func generateFunctionDummy(_ function: FunctionElement, annotation: MockAnnotation, useResult: Bool = false) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Dummy for \(function.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("// This is a dummy implementation that does nothing")
        output.append("")
        
        let functionName = "\(function.name)Dummy"
        let signature = generateFunctionSignature(function, name: functionName, useResult: useResult)
        
        output.append("\(signature) {")
        output.append("    // Dummy implementation - does nothing")
        
        if let returnType = function.returnType, returnType != "Void" {
            if useResult && function.isAsync {
                // For async functions with useResult, unwrap the Result and return the value
                output.append("    return try await returnValue.get()")
            } else {
                output.append("    return \(generateMinimalValue(for: returnType))")
            }
        }
        
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    // MARK: - Helper Methods
    
    private func generateDummyProperty(_ property: PropertyElement) -> String {
        let accessLevel = property.accessLevel.keyword
        let staticKeyword = property.isStatic ? "static " : ""
        let lazyKeyword = property.isLazy ? "lazy " : ""
        
        if property.hasSetter {
            return "\(accessLevel)\(staticKeyword)\(lazyKeyword)var \(property.name): \(property.type) = \(generateMinimalValue(for: property.type))"
        } else {
            return "\(accessLevel)\(staticKeyword)\(lazyKeyword)var \(property.name): \(property.type) { \(generateMinimalValue(for: property.type)) }"
        }
    }
    
    private func generateDummyPropertyOverride(_ property: PropertyElement) -> String {
        let accessLevel = property.accessLevel.keyword
        let staticKeyword = property.isStatic ? "static " : ""
        
        if property.hasSetter {
            return "\(accessLevel)override \(staticKeyword)var \(property.name): \(property.type) = \(generateMinimalValue(for: property.type))"
        } else {
            return "\(accessLevel)override \(staticKeyword)var \(property.name): \(property.type) { \(generateMinimalValue(for: property.type)) }"
        }
    }
    
    private func generateReturnValueProperty(_ method: MethodElement, useResult: Bool = false) -> String? {
        guard let returnType = method.returnType, returnType != "Void" else { return nil }
        
        if useResult && method.isAsync {
            // For async methods with useResult, use Result<T, Error> type
            let minimalValue = generateMinimalValue(for: returnType)
            return "var \(method.name)ReturnValue: Result<\(returnType), Error> = .success(\(minimalValue))"
        } else {
            let minimalValue = generateMinimalValue(for: returnType)
            return "var \(method.name)ReturnValue: \(returnType) = \(minimalValue)"
        }
    }
    
    private func generateDummyMethod(_ method: MethodElement, isMutable: Bool = false, useResult: Bool = false) -> String {
        let signature = generateMethodSignature(method, isMutable: isMutable, useResult: useResult)
        var body = [String]()
        
        body.append("// Dummy implementation - does nothing")
        
        if let returnType = method.returnType, returnType != "Void" {
            if useResult && method.isAsync {
                // For async methods with useResult, unwrap the Result and return the value
                body.append("return try await \(method.name)ReturnValue.get()")
            } else {
                body.append("return \(generateMinimalValue(for: returnType))")
            }
        }
        
        let bodyString = body.joined(separator: "\n        ")
        return "\(signature) {\n        \(bodyString)\n    }"
    }
    
    private func generateDummyMethodOverride(_ method: MethodElement, useResult: Bool = false) -> String {
        let signature = generateMethodOverrideSignature(method, useResult: useResult)
        var body = [String]()
        
        body.append("// Dummy implementation - does nothing")
        
        if let returnType = method.returnType, returnType != "Void" {
            if useResult && method.isAsync {
                // For async methods with useResult, unwrap the Result and return the value
                body.append("return try await \(method.name)ReturnValue.get()")
            } else {
                body.append("return \(generateMinimalValue(for: returnType))")
            }
        }
        
        let bodyString = body.joined(separator: "\n        ")
        return "\(signature) {\n        \(bodyString)\n    }"
    }
    
    private func generateDummyInitializer(_ initializer: InitializerElement) -> String {
        let accessLevel = initializer.accessLevel.keyword
        let convenience = initializer.isConvenience ? "convenience " : ""
        let failableMarker = initializer.isFailable ? "?" : ""
        let throwsKeyword = initializer.isThrowing ? " throws" : ""
        let parameters = generateParameterList(initializer.parameters)
        
        return "\(accessLevel)\(convenience)init\(failableMarker)(\(parameters))\(throwsKeyword) {\n        // Dummy implementation\n    }"
    }
    
    private func generateMethodSignature(_ method: MethodElement, isMutable: Bool = false, useResult: Bool = false) -> String {
        let accessLevel = method.accessLevel.keyword
        let staticKeyword = method.isStatic ? "static " : ""
        let mutatingKeyword = isMutable ? "mutating " : ""
        let asyncKeyword = method.isAsync ? " async" : ""
        let throwsKeyword = method.isThrowing ? " throws" : ""
        let parameters = generateParameterList(method.parameters)
        
        // Always keep the original signature - only change the returnValue type
        let returnClause = method.returnType.map { " -> \($0)" } ?? ""
        
        return "\(accessLevel)\(staticKeyword)\(mutatingKeyword)func \(method.name)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateMethodOverrideSignature(_ method: MethodElement, useResult: Bool = false) -> String {
        let accessLevel = method.accessLevel.keyword
        let staticKeyword = method.isStatic ? "static " : ""
        let asyncKeyword = method.isAsync ? " async" : ""
        let throwsKeyword = method.isThrowing ? " throws" : ""
        let parameters = generateParameterList(method.parameters)
        
        // Always keep the original signature - only change the returnValue type
        let returnClause = method.returnType.map { " -> \($0)" } ?? ""
        
        return "\(accessLevel)override \(staticKeyword)func \(method.name)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateFunctionSignature(_ function: FunctionElement, name: String, useResult: Bool = false) -> String {
        let accessLevel = function.accessLevel.keyword
        let staticKeyword = function.isStatic ? "static " : ""
        let asyncKeyword = function.isAsync ? " async" : ""
        let throwsKeyword = function.isThrowing ? " throws" : ""
        let parameters = generateParameterList(function.parameters)
        
        // Always keep the original signature - only change the returnValue type
        let returnClause = function.returnType.map { " -> \($0)" } ?? ""
        
        let genericClause = function.genericParameters.isEmpty ? "" : "<\(function.genericParameters.joined(separator: ", "))>"
        
        return "\(accessLevel)\(staticKeyword)func \(name)\(genericClause)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateParameterList(_ parameters: [ParameterElement]) -> String {
        return parameters.map { parameter in
            let externalName = parameter.externalName ?? parameter.internalName
            let inoutKeyword = parameter.isInout ? "inout " : ""
            let variadicMarker = parameter.isVariadic ? "..." : ""
            let defaultValueClause = parameter.defaultValue.map { " = \($0)" } ?? ""
            
            return "\(externalName) \(parameter.internalName): \(inoutKeyword)\(parameter.type)\(variadicMarker)\(defaultValueClause)"
        }.joined(separator: ", ")
    }
    
    /// Generate the most minimal possible value for a type (often nil for optionals, empty for collections)
    private func generateMinimalValue(for type: String) -> String {
        let cleanType = type.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Handle optional types - always return nil for dummies
        if cleanType.hasSuffix("?") {
            return "nil"
        }
        
        // Handle common types with minimal values
        switch cleanType {
        case "Bool":
            return "false"
        case "Int", "Int8", "Int16", "Int32", "Int64":
            return "0"
        case "UInt", "UInt8", "UInt16", "UInt32", "UInt64":
            return "0"
        case "Float", "Double", "CGFloat":
            return "0"
        case "String":
            return "\"\""
        case "Character":
            return "\" \""
        case "Void", "()":
            return "()"
        case let arrayType where arrayType.hasPrefix("[") && arrayType.hasSuffix("]"):
            return "[]"
        case let dictType where dictType.hasPrefix("[") && dictType.contains(":") && dictType.hasSuffix("]"):
            return "[:]"
        case let setType where setType.hasPrefix("Set<") && setType.hasSuffix(">"):
            return "[]"  // Empty set literal
        default:
            // For unknown types, try to use a failable initializer or force unwrap
            // This might fail at runtime but satisfies compile-time requirements
            if cleanType.contains("<") {
                // Generic type
                let baseType = String(cleanType.prefix(while: { $0 != "<" }))
                return "\(baseType)()"
            } else {
                // Regular type - try default initializer
                // For dummy, we might want to use force unwrap for some types
                return "\(cleanType)()"
            }
        }
    }
}
