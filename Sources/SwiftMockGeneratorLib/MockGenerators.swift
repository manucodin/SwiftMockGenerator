import Foundation

// MARK: - Mock Generator Protocol

/// Protocol for different types of mock generators
public protocol MockGeneratorProtocol {
    func generateMock(for element: CodeElement, annotation: MockAnnotation) throws -> String
}

// MARK: - Stub Generator

/// Generates stub implementations with default return values
public class StubGenerator: MockGeneratorProtocol {
    public init() {}
    
    public func generateMock(for element: CodeElement, annotation: MockAnnotation) throws -> String {
        switch element {
        case .protocol(let protocolElement):
            return generateProtocolStub(protocolElement, annotation: annotation)
        case .class(let classElement):
            return generateClassStub(classElement, annotation: annotation)
        case .function(let functionElement):
            return generateFunctionStub(functionElement, annotation: annotation)
        }
    }
    
    // MARK: - Protocol Stub Generation
    
    private func generateProtocolStub(_ protocolElement: ProtocolElement, annotation: MockAnnotation) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Stub for \(protocolElement.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("")
        
        // Class declaration
        let className = "\(protocolElement.name)Stub"
        let genericClause = protocolElement.genericParameters.isEmpty ? "" : "<\(protocolElement.genericParameters.joined(separator: ", "))>"
        let inheritanceClause = protocolElement.inheritance.isEmpty ? protocolElement.name : "\(protocolElement.name), \(protocolElement.inheritance.joined(separator: ", "))"
        
        output.append("\(protocolElement.accessLevel.keyword)class \(className)\(genericClause): \(inheritanceClause) {")
        output.append("")
        
        // Properties
        for property in protocolElement.properties {
            output.append("    \(generatePropertyStub(property))")
        }
        
        if !protocolElement.properties.isEmpty && !protocolElement.methods.isEmpty {
            output.append("")
        }
        
        // Initializer
        output.append("    \(protocolElement.accessLevel.keyword)init() {}")
        
        if !protocolElement.methods.isEmpty {
            output.append("")
        }
        
        // Methods
        for method in protocolElement.methods {
            output.append("    \(generateMethodStub(method))")
            output.append("")
        }
        
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    // MARK: - Class Stub Generation
    
    private func generateClassStub(_ classElement: ClassElement, annotation: MockAnnotation) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Stub for \(classElement.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("")
        
        // Class declaration
        let className = "\(classElement.name)Stub"
        let genericClause = classElement.genericParameters.isEmpty ? "" : "<\(classElement.genericParameters.joined(separator: ", "))>"
        let inheritanceClause = classElement.inheritance.isEmpty ? classElement.name : "\(classElement.name), \(classElement.inheritance.joined(separator: ", "))"
        
        output.append("\(classElement.accessLevel.keyword)class \(className)\(genericClause): \(inheritanceClause) {")
        output.append("")
        
        // Override properties if needed
        for property in classElement.properties {
            output.append("    \(generatePropertyOverrideStub(property))")
        }
        
        if !classElement.properties.isEmpty && (!classElement.initializers.isEmpty || !classElement.methods.isEmpty) {
            output.append("")
        }
        
        // Initializers
        if !classElement.initializers.isEmpty {
            for initializer in classElement.initializers {
                output.append("    \(generateInitializerStub(initializer))")
                output.append("")
            }
        } else {
            output.append("    \(classElement.accessLevel.keyword)override init() {")
            output.append("        super.init()")
            output.append("    }")
            output.append("")
        }
        
        // Override methods
        for method in classElement.methods {
            output.append("    \(generateMethodOverrideStub(method))")
            output.append("")
        }
        
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    
    // MARK: - Function Stub Generation
    
    private func generateFunctionStub(_ function: FunctionElement, annotation: MockAnnotation) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Stub for \(function.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("")
        
        let functionName = "\(function.name)Stub"
        let signature = generateFunctionSignature(function, name: functionName)
        
        output.append("\(signature) {")
        
        if let returnType = function.returnType, returnType != "Void" {
            output.append("    return \(generateDefaultValue(for: returnType))")
        }
        
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    // MARK: - Helper Methods
    
    private func generatePropertyStub(_ property: PropertyElement) -> String {
        let accessLevel = property.accessLevel.keyword
        let staticKeyword = property.isStatic ? "static " : ""
        let lazyKeyword = property.isLazy ? "lazy " : ""
        
        if property.hasSetter {
            return "\(accessLevel)\(staticKeyword)\(lazyKeyword)var \(property.name): \(property.type) = \(generateDefaultValue(for: property.type))"
        } else {
            return "\(accessLevel)\(staticKeyword)\(lazyKeyword)var \(property.name): \(property.type) { \(generateDefaultValue(for: property.type)) }"
        }
    }
    
    private func generatePropertyOverrideStub(_ property: PropertyElement) -> String {
        let accessLevel = property.accessLevel.keyword
        let staticKeyword = property.isStatic ? "static " : ""
        
        if property.hasSetter {
            return "\(accessLevel)override \(staticKeyword)var \(property.name): \(property.type) = \(generateDefaultValue(for: property.type))"
        } else {
            return "\(accessLevel)override \(staticKeyword)var \(property.name): \(property.type) { \(generateDefaultValue(for: property.type)) }"
        }
    }
    
    private func generateMethodStub(_ method: MethodElement, isMutable: Bool = false) -> String {
        let signature = generateMethodSignature(method, isMutable: isMutable)
        var body = [String]()
        
        if let returnType = method.returnType, returnType != "Void" {
            body.append("return \(generateDefaultValue(for: returnType))")
        }
        
        let bodyString = body.isEmpty ? "" : "\n        \(body.joined(separator: "\n        "))\n    "
        return "\(signature) {\(bodyString)}"
    }
    
    private func generateMethodOverrideStub(_ method: MethodElement) -> String {
        let signature = generateMethodOverrideSignature(method)
        var body = [String]()
        
        if let returnType = method.returnType, returnType != "Void" {
            body.append("return \(generateDefaultValue(for: returnType))")
        }
        
        let bodyString = body.isEmpty ? "" : "\n        \(body.joined(separator: "\n        "))\n    "
        return "\(signature) {\(bodyString)}"
    }
    
    private func generateInitializerStub(_ initializer: InitializerElement) -> String {
        let accessLevel = initializer.accessLevel.keyword
        let convenience = initializer.isConvenience ? "convenience " : ""
        let failableMarker = initializer.isFailable ? "?" : ""
        let throwsKeyword = initializer.isThrowing ? " throws" : ""
        let parameters = generateParameterList(initializer.parameters)
        
        return "\(accessLevel)\(convenience)init\(failableMarker)(\(parameters))\(throwsKeyword) {}"
    }
    
    private func generateMethodSignature(_ method: MethodElement, isMutable: Bool = false) -> String {
        let accessLevel = method.accessLevel.keyword
        let staticKeyword = method.isStatic ? "static " : ""
        let mutatingKeyword = isMutable ? "mutating " : ""
        let asyncKeyword = method.isAsync ? " async" : ""
        let throwsKeyword = method.isThrowing ? " throws" : ""
        let parameters = generateParameterList(method.parameters)
        let returnClause = method.returnType.map { " -> \($0)" } ?? ""
        
        return "\(accessLevel)\(staticKeyword)\(mutatingKeyword)func \(method.name)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateMethodOverrideSignature(_ method: MethodElement) -> String {
        let accessLevel = method.accessLevel.keyword
        let staticKeyword = method.isStatic ? "static " : ""
        let asyncKeyword = method.isAsync ? " async" : ""
        let throwsKeyword = method.isThrowing ? " throws" : ""
        let parameters = generateParameterList(method.parameters)
        let returnClause = method.returnType.map { " -> \($0)" } ?? ""
        
        return "\(accessLevel)override \(staticKeyword)func \(method.name)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateFunctionSignature(_ function: FunctionElement, name: String) -> String {
        let accessLevel = function.accessLevel.keyword
        let staticKeyword = function.isStatic ? "static " : ""
        let asyncKeyword = function.isAsync ? " async" : ""
        let throwsKeyword = function.isThrowing ? " throws" : ""
        let parameters = generateParameterList(function.parameters)
        let returnClause = function.returnType.map { " -> \($0)" } ?? ""
        let genericClause = function.genericParameters.isEmpty ? "" : "<\(function.genericParameters.joined(separator: ", "))>"
        
        return "\(accessLevel)\(staticKeyword)func \(name)\(genericClause)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateParameterList(_ parameters: [ParameterElement]) -> String {
        return parameters.map { parameter in
            let externalName = parameter.externalName ?? parameter.internalName
            let inoutKeyword = parameter.isInout ? "inout " : ""
            let variadicMarker = parameter.isVariadic ? "..." : ""
            let defaultValueClause = parameter.defaultValue.map { " = \($0)" } ?? ""
            
            return "\(externalName) \(parameter.internalName): \(inoutKeyword)\(parameter.type)\(variadicMarker)\(defaultValueClause)"
        }.joined(separator: ", ")
    }
    
    private func generateDefaultValue(for type: String) -> String {
        let cleanType = type.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Handle optional types
        if cleanType.hasSuffix("?") {
            return "nil"
        }
        
        // Handle common types
        switch cleanType {
        case "Bool":
            return "false"
        case "Int", "Int8", "Int16", "Int32", "Int64":
            return "0"
        case "UInt", "UInt8", "UInt16", "UInt32", "UInt64":
            return "0"
        case "Float", "Double", "CGFloat":
            return "0.0"
        case "String":
            return "\"\""
        case "Character":
            return "\" \""
        case "Void", "()":
            return "()"
        case let arrayType where arrayType.hasPrefix("[") && arrayType.hasSuffix("]"):
            return "[]"
        case let dictType where dictType.hasPrefix("[") && dictType.contains(":") && dictType.hasSuffix("]"):
            return "[:]"
        case let setType where setType.hasPrefix("Set<") && setType.hasSuffix(">"):
            return "Set()"
        default:
            // Try to create a default initializer
            if cleanType.contains("<") {
                // Generic type, use default initializer
                let baseType = String(cleanType.prefix(while: { $0 != "<" }))
                return "\(baseType)()"
            } else {
                // Regular type, use default initializer
                return "\(cleanType)()"
            }
        }
    }
}
