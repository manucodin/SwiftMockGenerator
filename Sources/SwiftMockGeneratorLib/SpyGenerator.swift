import Foundation

// MARK: - Spy Generator

/// Generates spy implementations that record method calls and parameters
public class SpyGenerator: MockGeneratorProtocol {
    public init() {}
    
    public func generateMock(for element: CodeElement, annotation: MockAnnotation, useResult: Bool = false) throws -> String {
        switch element {
        case .protocol(let protocolElement):
            return generateProtocolSpy(protocolElement, annotation: annotation, useResult: useResult)
        case .class(let classElement):
            return generateClassSpy(classElement, annotation: annotation, useResult: useResult)
        case .function(let functionElement):
            return generateFunctionSpy(functionElement, annotation: annotation, useResult: useResult)
        }
    }
    
    public func generateMockDefinition(for element: CodeElement, annotation: MockAnnotation, useResult: Bool = false) throws -> String {
        // Get the full mock code and remove the header (first 2 lines)
        let fullMock = try generateMock(for: element, annotation: annotation, useResult: useResult)
        let lines = fullMock.components(separatedBy: .newlines)
        return lines.dropFirst(2).joined(separator: "\n")
    }
    
    // MARK: - Protocol Spy Generation
    
    private func generateProtocolSpy(_ protocolElement: ProtocolElement, annotation: MockAnnotation, useResult: Bool = false) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Spy for \(protocolElement.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("")
        
        // Class declaration
        let className = "\(protocolElement.name)Spy"
        let genericClause = protocolElement.genericParameters.isEmpty ? "" : "<\(protocolElement.genericParameters.joined(separator: ", "))>"
        let inheritanceClause = protocolElement.inheritance.isEmpty ? protocolElement.name : "\(protocolElement.name), \(protocolElement.inheritance.joined(separator: ", "))"
        
        output.append("\(protocolElement.accessLevel.keyword)class \(className)\(genericClause): \(inheritanceClause) {")
        output.append("")
        
        // Properties implementation
        for property in protocolElement.properties {
            output.append("    \(generateSpyProperty(property))")
        }
        
        if !protocolElement.properties.isEmpty {
            output.append("")
        }
        
        // Initializer
        output.append("    \(protocolElement.accessLevel.keyword)init() {}")
        output.append("")
        
        // Reset method
        output.append("    // MARK: - Reset")
        output.append("    \(protocolElement.accessLevel.keyword)func resetSpy() {")
        
        for method in protocolElement.methods {
            output.append("        \(method.name)CallCount = 0")
            output.append("        \(method.name)CallParameters = []")
        }
        
        output.append("    }")
        
        // Methods implementation with tracking variables above each method
        for method in protocolElement.methods {
            output.append("")
            output.append("    // MARK: - \(method.name)")
            output.append("    \(generateCallCountProperty(for: method))")
            output.append("    \(generateCallParametersProperty(for: method))")
            
            // Add return value property if method has return type
            if let returnType = method.returnType, returnType != "Void" {
                output.append("    \(generateReturnValueProperty(for: method, useResult: useResult))")
            }
            
            // Add throw error property if method can throw (only if not using Result)
            if method.isThrowing && !(useResult && method.isAsync) {
                output.append("    \(generateThrowErrorProperty(for: method))")
            }
            
            output.append("")
            output.append("    \(generateSpyMethod(method, useResult: useResult))")
        }
        
        output.append("")
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    // MARK: - Class Spy Generation
    
    private func generateClassSpy(_ classElement: ClassElement, annotation: MockAnnotation, useResult: Bool = false) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Spy for \(classElement.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("")
        
        // Class declaration
        let className = "\(classElement.name)Spy"
        let genericClause = classElement.genericParameters.isEmpty ? "" : "<\(classElement.genericParameters.joined(separator: ", "))>"
        let inheritanceClause = classElement.inheritance.isEmpty ? classElement.name : "\(classElement.name), \(classElement.inheritance.joined(separator: ", "))"
        
        output.append("\(classElement.accessLevel.keyword)class \(className)\(genericClause): \(inheritanceClause) {")
        output.append("")
        
        // Initializers
        if !classElement.initializers.isEmpty {
            for initializer in classElement.initializers {
                output.append("    \(generateSpyInitializer(initializer))")
                output.append("")
            }
        } else {
            output.append("    \(classElement.accessLevel.keyword)override init() {")
            output.append("        super.init()")
            output.append("    }")
            output.append("")
        }
        
        // Reset method
        output.append("    // MARK: - Reset")
        output.append("    \(classElement.accessLevel.keyword)func resetSpy() {")
        
        for method in classElement.methods {
            output.append("        \(method.name)CallCount = 0")
            output.append("        \(method.name)CallParameters = []")
        }
        
        output.append("    }")
        
        // Override methods with tracking variables above each method
        for method in classElement.methods {
            output.append("")
            output.append("    // MARK: - \(method.name)")
            output.append("    \(generateCallCountProperty(for: method))")
            output.append("    \(generateCallParametersProperty(for: method))")
            
            // Add return value property if method has return type
            if let returnType = method.returnType, returnType != "Void" {
                output.append("    \(generateReturnValueProperty(for: method, useResult: useResult))")
            }
            
            // Add throw error property if method can throw (only if not using Result)
            if method.isThrowing && !(useResult && method.isAsync) {
                output.append("    \(generateThrowErrorProperty(for: method))")
            }
            
            output.append("")
            output.append("    \(generateSpyMethodOverride(method, useResult: useResult))")
        }
        
        output.append("")
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    
    // MARK: - Function Spy Generation
    
    private func generateFunctionSpy(_ function: FunctionElement, annotation: MockAnnotation, useResult: Bool = false) -> String {
        var output = [String]()
        
        // Header comment
        output.append("// MARK: - Generated Spy for \(function.name)")
        output.append("// Generated by SwiftMockGenerator")
        output.append("")
        
        let className = "\(function.name.capitalized)Spy"
        
        output.append("\(function.accessLevel.keyword)class \(className) {")
        output.append("")
        
        // Call tracking properties
        output.append("    // MARK: - Call Tracking")
        output.append("    private(set) var callCount = 0")
        
        if !function.parameters.isEmpty {
            output.append("    private(set) var callParameters: [(\(generateParameterTupleType(function.parameters)))] = []")
        }
        
        // Return value storage
        if let returnType = function.returnType, returnType != "Void" {
            output.append("")
            output.append("    // MARK: - Return Value")
            if useResult && function.isAsync {
                output.append("    var returnValue: Result<\(returnType), Error> = .success(\(generateDefaultValue(for: returnType)))")
            } else {
                output.append("    var returnValue: \(returnType) = \(generateDefaultValue(for: returnType))")
            }
        }
        
        output.append("")
        
        // Initializer
        output.append("    \(function.accessLevel.keyword)init() {}")
        output.append("")
        
        // Reset method
        output.append("    \(function.accessLevel.keyword)func reset() {")
        output.append("        callCount = 0")
        if !function.parameters.isEmpty {
            output.append("        callParameters = []")
        }
        output.append("    }")
        output.append("")
        
        // Call method
        let functionName = function.name
        let signature = generateSpyFunctionSignature(function, name: "call\(functionName.capitalized)", useResult: useResult)
        
        output.append("    \(signature) {")
        output.append("        callCount += 1")
        
        if !function.parameters.isEmpty {
            let parameterNames = function.parameters.map { $0.internalName }
            output.append("        callParameters.append((\(parameterNames.joined(separator: ", "))))")
        }
        
        if let returnType = function.returnType, returnType != "Void" {
            if useResult && function.isAsync {
                output.append("        return returnValue")
            } else {
                output.append("        return returnValue")
            }
        }
        
        output.append("    }")
        
        output.append("}")
        
        return output.joined(separator: "\n")
    }
    
    // MARK: - Helper Methods
    
    private func generateCallCountProperty(for method: MethodElement) -> String {
        return "private(set) var \(method.name)CallCount = 0"
    }
    
    private func generateCallParametersProperty(for method: MethodElement) -> String {
        if method.parameters.isEmpty {
            return "private(set) var \(method.name)CallParameters: [Void] = []"
        }
        
        let tupleType = generateParameterTupleType(method.parameters)
        return "private(set) var \(method.name)CallParameters: [(\(tupleType))] = []"
    }
    
    private func generateReturnValueProperty(for method: MethodElement, useResult: Bool = false) -> String {
        guard let returnType = method.returnType, returnType != "Void" else { return "" }
        
        if useResult && method.isAsync {
            // For async methods with useResult, the return type should be Result<T, Error>
            return "var \(method.name)ReturnValue: Result<\(returnType), Error> = .success(\(generateDefaultValue(for: returnType)))"
        } else {
            return "var \(method.name)ReturnValue: \(returnType) = \(generateDefaultValue(for: returnType))"
        }
    }
    
    private func generateThrowErrorProperty(for method: MethodElement) -> String {
        guard method.isThrowing else { return "" }
        return "var \(method.name)ThrowError: Error?"
    }
    
    private func generateSpyProperty(_ property: PropertyElement) -> String {
        let accessLevel = property.accessLevel.keyword
        let staticKeyword = property.isStatic ? "static " : ""
        
        if property.hasSetter {
            return "\(accessLevel)\(staticKeyword)var \(property.name): \(property.type) = \(generateDefaultValue(for: property.type))"
        } else {
            return "\(accessLevel)\(staticKeyword)var \(property.name): \(property.type) { \(generateDefaultValue(for: property.type)) }"
        }
    }
    
    private func generateSpyMethod(_ method: MethodElement, useResult: Bool = false) -> String {
        let signature = generateMethodSignature(method, isMutable: method.isMutating, useResult: useResult)
        var body = [String]()
        
        body.append("\(method.name)CallCount += 1")
        
        if method.parameters.isEmpty {
            body.append("\(method.name)CallParameters.append(())")
        } else {
            let parameterNames = method.parameters.map { $0.internalName }
            body.append("\(method.name)CallParameters.append((\(parameterNames.joined(separator: ", "))))")
        }
        
        if let returnType = method.returnType, returnType != "Void" {
            if useResult && method.isAsync {
                // For async methods with useResult, return the Result directly
                body.append("return \(method.name)ReturnValue")
            } else {
                // Throw error if configured (only for non-Result methods)
                if method.isThrowing {
                    body.append("if let error = \(method.name)ThrowError { throw error }")
                }
                body.append("return \(method.name)ReturnValue")
            }
        } else if method.isThrowing && !(useResult && method.isAsync) {
            // For void methods that can throw (and not using Result)
            body.append("if let error = \(method.name)ThrowError { throw error }")
        }
        
        let bodyString = body.joined(separator: "\n        ")
        return "\(signature) {\n        \(bodyString)\n    }"
    }
    
    private func generateSpyMethodOverride(_ method: MethodElement, useResult: Bool = false) -> String {
        let signature = generateMethodOverrideSignature(method, useResult: useResult)
        var body = [String]()
        
        body.append("\(method.name)CallCount += 1")
        
        if method.parameters.isEmpty {
            body.append("\(method.name)CallParameters.append(())")
        } else {
            let parameterNames = method.parameters.map { $0.internalName }
            body.append("\(method.name)CallParameters.append((\(parameterNames.joined(separator: ", "))))")
        }
        
        if let returnType = method.returnType, returnType != "Void" {
            if useResult && method.isAsync {
                // For async methods with useResult, return the Result directly
                body.append("return \(method.name)ReturnValue")
            } else {
                // Throw error if configured (only for non-Result methods)
                if method.isThrowing {
                    body.append("if let error = \(method.name)ThrowError { throw error }")
                }
                body.append("return \(method.name)ReturnValue")
            }
        } else if method.isThrowing && !(useResult && method.isAsync) {
            // For void methods that can throw (and not using Result)
            body.append("if let error = \(method.name)ThrowError { throw error }")
        }
        
        let bodyString = body.joined(separator: "\n        ")
        return "\(signature) {\n        \(bodyString)\n    }"
    }
    
    private func generateSpyInitializer(_ initializer: InitializerElement) -> String {
        let accessLevel = initializer.accessLevel.keyword
        let convenience = initializer.isConvenience ? "convenience " : ""
        let failableMarker = initializer.isFailable ? "?" : ""
        let throwsKeyword = initializer.isThrowing ? " throws" : ""
        let parameters = generateParameterList(initializer.parameters)
        
        return "\(accessLevel)\(convenience)override init\(failableMarker)(\(parameters))\(throwsKeyword) {\n        super.init()\n    }"
    }
    
    private func generateParameterTupleType(_ parameters: [ParameterElement]) -> String {
        if parameters.isEmpty { return "" }
        
        let types = parameters.map { parameter in
            let inoutKeyword = parameter.isInout ? "inout " : ""
            let variadicMarker = parameter.isVariadic ? "..." : ""
            return "\(inoutKeyword)\(parameter.type)\(variadicMarker)"
        }
        
        return types.joined(separator: ", ")
    }
    
    private func generateMethodSignature(_ method: MethodElement, isMutable: Bool = false, useResult: Bool = false) -> String {
        let accessLevel = method.accessLevel.keyword
        let staticKeyword = method.isStatic ? "static " : ""
        let mutatingKeyword = isMutable ? "mutating " : ""
        let asyncKeyword = method.isAsync ? " async" : ""
        let throwsKeyword = method.isThrowing ? " throws" : ""
        let parameters = generateParameterList(method.parameters)
        
        let returnClause: String
        if useResult && method.isAsync, let returnType = method.returnType, returnType != "Void" {
            // Convert async throws -> T to -> Result<T, Error>
            returnClause = " -> Result<\(returnType), Error>"
        } else {
            returnClause = method.returnType.map { " -> \($0)" } ?? ""
        }
        
        return "\(accessLevel)\(staticKeyword)\(mutatingKeyword)func \(method.name)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateMethodOverrideSignature(_ method: MethodElement, useResult: Bool = false) -> String {
        let accessLevel = method.accessLevel.keyword
        let staticKeyword = method.isStatic ? "static " : ""
        let asyncKeyword = method.isAsync ? " async" : ""
        let throwsKeyword = method.isThrowing ? " throws" : ""
        let parameters = generateParameterList(method.parameters)
        
        let returnClause: String
        if useResult && method.isAsync, let returnType = method.returnType, returnType != "Void" {
            // Convert async throws -> T to -> Result<T, Error>
            returnClause = " -> Result<\(returnType), Error>"
        } else {
            returnClause = method.returnType.map { " -> \($0)" } ?? ""
        }
        
        return "\(accessLevel)override \(staticKeyword)func \(method.name)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateSpyFunctionSignature(_ function: FunctionElement, name: String, useResult: Bool = false) -> String {
        let accessLevel = function.accessLevel.keyword
        let asyncKeyword = function.isAsync ? " async" : ""
        let throwsKeyword = function.isThrowing ? " throws" : ""
        let parameters = generateParameterList(function.parameters)
        
        let returnClause: String
        if useResult && function.isAsync, let returnType = function.returnType, returnType != "Void" {
            // Convert async throws -> T to -> Result<T, Error>
            returnClause = " -> Result<\(returnType), Error>"
        } else {
            returnClause = function.returnType.map { " -> \($0)" } ?? ""
        }
        
        return "\(accessLevel)func \(name)(\(parameters))\(asyncKeyword)\(throwsKeyword)\(returnClause)"
    }
    
    private func generateParameterList(_ parameters: [ParameterElement]) -> String {
        return parameters.map { parameter in
            let externalName = parameter.externalName ?? parameter.internalName
            let inoutKeyword = parameter.isInout ? "inout " : ""
            let variadicMarker = parameter.isVariadic ? "..." : ""
            let defaultValueClause = parameter.defaultValue.map { " = \($0)" } ?? ""
            
            return "\(externalName) \(parameter.internalName): \(inoutKeyword)\(parameter.type)\(variadicMarker)\(defaultValueClause)"
        }.joined(separator: ", ")
    }
    
    private func generateDefaultValue(for type: String) -> String {
        let cleanType = type.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Handle optional types
        if cleanType.hasSuffix("?") {
            return "nil"
        }
        
        // Handle common types
        switch cleanType {
        case "Bool":
            return "false"
        case "Int", "Int8", "Int16", "Int32", "Int64":
            return "0"
        case "UInt", "UInt8", "UInt16", "UInt32", "UInt64":
            return "0"
        case "Float", "Double", "CGFloat":
            return "0.0"
        case "String":
            return "\"\""
        case "Character":
            return "\" \""
        case "Void", "()":
            return "()"
        case let arrayType where arrayType.hasPrefix("[") && arrayType.hasSuffix("]"):
            return "[]"
        case let dictType where dictType.hasPrefix("[") && dictType.contains(":") && dictType.hasSuffix("]"):
            return "[:]"
        case let setType where setType.hasPrefix("Set<") && setType.hasSuffix(">"):
            return "Set()"
        default:
            // Try to create a default initializer
            if cleanType.contains("<") {
                // Generic type, use default initializer
                let baseType = String(cleanType.prefix(while: { $0 != "<" }))
                return "\(baseType)()"
            } else {
                // Regular type, use default initializer
                return "\(cleanType)()"
            }
        }
    }
}
